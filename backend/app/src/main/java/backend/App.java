/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package backend;

// import io.vertx.core.Future;
// import io.vertx.core.Promise;
// import io.vertx.core.CompositeFuture;


import java.util.List;
import java.util.ArrayList;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.Tuple;

// import io.vertx.sqlclient.RowSet;
// import io.vertx.sqlclient.Row;


import io.vertx.core.http.HttpMethod;
import io.vertx.core.json.*;

import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

import io.vertx.core.*;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.CorsHandler;

public class App extends AbstractVerticle{

    private JDBCClient client;
    
    @Override
    public void start(){

        // ========  connection with database ======== //
        JsonObject config = new JsonObject()
        .put("url", "jdbc:mysql://localhost:3306/crud_db")            // Database password
        .put("max_pool_size", 30)                                 // Database URL
        .put("driver_class", "com.mysql.cj.jdbc.Driver")          // MySQL driver
        .put("user", "shawon")                                      // Database username
        .put("password", "1234");                                  // Max pool size (optional)
   
        // Create JDBC client
        client = JDBCClient.createShared(vertx, config);



        Router router = Router.router(vertx);

        router.route().handler(CorsHandler.create("*")  // Allow requests from any origin
        .allowedMethod(HttpMethod.GET)             // Allow specific HTTP methods
        .allowedMethod(HttpMethod.POST)
        .allowedMethod(HttpMethod.PUT)
        .allowedMethod(HttpMethod.DELETE)
        .allowedHeader("Access-Control-Allow-Headers")
        .allowedHeader("Content-Type")
        .allowedHeader("Authorization"));


        router.get("/tasks").handler(this:: getTasks);
        router.post("/task").handler(this:: postTask);

        router.post("/state").handler(this:: saveState);
        router.get("/state").handler(this:: getState);

        
        // Create an HTTP server
        vertx.createHttpServer()
            .requestHandler(router)
            .listen(8080,res->{
                if(res.succeeded()){
                    System.out.println("server started at http://localhost:8080");
                }else{
                    System.out.println(res);
                }
            });     
    }

    public Future<JsonArray> fetchDataSequentially() {
        Promise<JsonArray> mainPromise = Promise.promise();
        JsonArray resultArray = new JsonArray();
    
        // Step 1: Fetch States
        String stateQuery = "SELECT * FROM state";
        client.query(stateQuery, stateRes -> {
            if (stateRes.succeeded()) {
                JsonArray stateRows = new JsonArray(stateRes.result().getRows().toString());
    
                // Process each state one by one
                List<Future> stateFutures = new ArrayList<>();
    
                for (int i = 0; i < stateRows.size(); i++) {
                    JsonObject stateRow = stateRows.getJsonObject(i);
                    JsonObject stateJson = new JsonObject()
                            .put("id", stateRow.getString("id"))
                            .put("viewport", new JsonObject(stateRow.getString("viewport")))
                            .put("metadata", new JsonObject(stateRow.getString("metadata")));
    
                    // Step 2: Fetch Nodes for the current state
                    Promise<Void> statePromise = Promise.promise();
                    String nodesQuery = "SELECT * FROM nodes WHERE parent_id = '" + stateRow.getString("id") + "';";
                    client.query(nodesQuery, nodesRes -> {
                        if (nodesRes.succeeded()) {
                            JsonArray nodesArray = new JsonArray();
                            JsonArray nodeRows = new JsonArray(nodesRes.result().getRows().toString());
    
                            for (int j = 0; j < nodeRows.size(); j++) {
                                JsonObject nodeRow = nodeRows.getJsonObject(j);
                                JsonObject nodeJson = new JsonObject()
                                        .put("id", nodeRow.getString("id"))
                                        .put("data", new JsonObject(nodeRow.getString("data")))
                                        .put("type", nodeRow.getString("type"))
                                        .put("position", new JsonObject(nodeRow.getString("position")));
                                nodesArray.add(nodeJson);
                            }
    
                            stateJson.put("nodes", nodesArray);
    
                            // Step 3: Fetch Edges for the current state
                            String edgesQuery = "SELECT * FROM edges WHERE parent_id = '" + stateRow.getString("id") + "';";
                            client.query(edgesQuery, edgesRes -> {
                                if (edgesRes.succeeded()) {
                                    JsonArray edgesArray = new JsonArray();
                                    JsonArray edgeRows = new JsonArray(edgesRes.result().getRows().toString());
    
                                    for (int k = 0; k < edgeRows.size(); k++) {
                                        JsonObject edgeRow = edgeRows.getJsonObject(k);
                                        JsonObject edgeJson = new JsonObject()
                                                .put("id", edgeRow.getString("id"))
                                                .put("source", edgeRow.getString("source"))
                                                .put("target", edgeRow.getString("target"))
                                                .put("sourceHandle", edgeRow.getString("source_handle"))
                                                .put("targetHandle", edgeRow.getString("target_handle"));
                                        edgesArray.add(edgeJson);
                                    }
    
                                    stateJson.put("edges", edgesArray);
    
                                    // Add the state object to the result array
                                    resultArray.add(stateJson);
    
                                    // Complete the promise for this state
                                    statePromise.complete();
                                } else {
                                    statePromise.fail(edgesRes.cause());
                                }
                            });
    
                        } else {
                            statePromise.fail(nodesRes.cause());
                        }
                    });
    
                    stateFutures.add(statePromise.future());
                }
    
                // Wait for all state futures to complete
                CompositeFuture.all(stateFutures).onComplete(ar -> {
                    if (ar.succeeded()) {
                        mainPromise.complete(resultArray);
                    } else {
                        mainPromise.fail(ar.cause());
                    }
                });
    
            } else {
                mainPromise.fail(stateRes.cause());
            }
        });
    
        return mainPromise.future();
    }
    

    private void getState(RoutingContext context){
        fetchDataSequentially().onComplete(ar -> {
            if (ar.succeeded()) {
                // Send the result as JSON response
                context.response()
                        .setStatusCode(200)
                        .setStatusMessage("ok")
                        .end(ar.result().toString());
            } else {
                // Handle failure
                context.response()
                        .setStatusCode(500)
                        .putHeader("Content-Type", "application/json")
                        .end(new JsonObject().put("error", ar.cause().getMessage()).encode());
            }
        });
    }
    
    private void getTasks(RoutingContext context){
        HttpMethod method = context.request().method();
        System.out.println("HTTP method is "+ method);

        String path = context.request().path();
        // System.out.println("path is "+path);

        String query = "Select * from tasks;";

        client.query(query,res->{
            if(res.succeeded()){
                
                JsonArray jsonArray = new JsonArray(res.result().getRows().toString());

                context.response()
                .setStatusCode(200)
                .setStatusMessage("ok")
                .end(jsonArray.toString());
            }else{
                context.response().end("Database error");
            }
        });
    }
    

    
        

    private void saveState(RoutingContext context){
            context.request().bodyHandler(res->{
            String cntRcvd = res.toString();

            // System.out.println(cntRcvd);

            JsonObject jsonObject = new JsonObject(cntRcvd);

            JsonArray nodesArray = jsonObject.getJsonArray("nodes");
            JsonArray edgesArray = jsonObject.getJsonArray("edges");

            System.out.println(cntRcvd);

            String stateQuery = "insert into state (id,viewport,metadata) values("
                   + "'" + jsonObject.getString("id") + "'" + ","
                   + "'" + jsonObject.getJsonObject("viewport") + "'" + ","
                   + "'" + jsonObject.getJsonObject("metadata") + "'" + ");";

                //    System.out.println(jsonObject.getString("id"));
            
            client.query(stateQuery,resp->{
                if(resp.succeeded()){

                    for(int i=0;i<nodesArray.size();i++){
                        JsonObject node = new JsonObject(nodesArray.getJsonObject(i).toString());
                        JsonObject data = node.getJsonObject("data");
                        String inputStr = node.getJsonObject("data").getString("input_format");
                        // System.out.println(inputStr);
                        node.getJsonObject("data").put("input_format",new JsonObject(inputStr));
                        
                        if(data.containsKey("output_format")){
                            String outputStr = node.getJsonObject("data").getString("output_format");
                            // System.out.println(node.getJsonObject("data"));
                            node.getJsonObject("data").put("output_format",new JsonObject(outputStr));
                        }


                        if(data.containsKey("eta")){
                            String eta = node.getJsonObject("data").getString("eta");
                            // System.out.println(node.getJsonObject("data"));
                            node.getJsonObject("data").put("eta",new JsonObject(eta));
                        }

                        if(data.containsKey("header")){
                            String headerStr = node.getJsonObject("data").getString("header");
                            // System.out.println(node.getJsonObject("data"));
                            node.getJsonObject("data").put("header",new JsonObject(headerStr));
                        }


                        // System.out.println(node.getJsonObject("data"));   
        
                        String nodeQuery = "insert into nodes (id,type,position,data,width,height,selected,dragging,parent_id) values ("
                                 + "'" + node.getString("id") + "'" + ","
                                 + "'" + node.getString("type") + "'" + ","
                                 + "'" + node.getJsonObject("position") + "'" + ","
                                 + "'" + node.getJsonObject("data") + "'" + ","
                                 +  node.getString("width") + ","
                                 +  node.getString("height") + ","
                                 +  node.getString("selected") + ","
                                 +  node.getString("dragging") + ","
                                 + "'" + jsonObject.getString("id") + "'" + ");";

                              
                        
                        client.query(nodeQuery,nodeResponse->{
                            if(nodeResponse.succeeded()){
                                // continue;
                            }else{
                                context.response().end("Database error due to nodes table");
                                return;
                            }
                        });    
                    }
        
                    for(int i=0;i<edgesArray.size();i++){
                        JsonObject edge = new JsonObject(edgesArray.getJsonObject(i).toString());
                        
                        
        
                        String edgeQuery = "insert into edges (id,source,target,type,selected,parent_id) values ("
                        + "'" + edge.getString("id") +"'"+","
                        + "'" + edge.getString("source") +"'"+","
                        + "'" + edge.getString("target") +"'"+","
                        + "'" + edge.getString("type") +"'"+","
                        + edge.getString("selected") +","
                        + "'" + jsonObject.getString("id") +"'"+");";
                        
                        client.query(edgeQuery,edgeResponse->{
                            if(edgeResponse.succeeded()){
                            }else{
                                context.response().end("Database error due to edges table");
                                return;
                            }
                        }); 
                    }
                    context.response()
                    .setStatusCode(200)
                    .setStatusMessage("ok")
                    .end("Data added to state nodes and edges");
                }else{
                    context.response().setStatusCode(500).end("Database error due to state table");
                }
            });

        });
    }

    
    

    private void postTask(RoutingContext context){
        HttpMethod method = context.request().method();
        System.out.println("HTTP method is "+ method);

        context.request().bodyHandler(res->{
            String cntRcvd = res.toString();

            JsonObject jsonMain = new JsonObject(cntRcvd);
            
            // System.out.println(jsonMain);

            JsonObject jsonObject = new JsonObject((jsonMain.getJsonObject("data")).toString());
            
            

            String query = "insert into tasks ("+
                                "id,name,slug,description,help_text,"+
                                "input_format,output_format,dependent_task_slug,repeats_on,"+
                                "bulk_input,input_http_method,api_endpoint,api_timeout_in_ms,"+
                                "response_type,is_json_input_needed,task_type,is_active,is_optional,"+
                                "eta,service_id,email_list,action)"+"values("+
                                "'" + jsonMain.getString("id")+"'"+","+
                                "'" + jsonObject.getString("name")+ "'"+ ","+
                                "'" +jsonObject.getString("slug")+ "'"+","+
                                "'" +jsonObject.getString("description")+"'"+","+
                                "'" +jsonObject.getString("help_text")+"'"+","+
                                "'" + jsonObject.getString("input_format") +"'"+","+
                                "'" + jsonObject.getString("output_format")+"'"+","+
                                "'" +jsonObject.getString("dependent_task_slug")+"'"+","+
                                jsonObject.getString("repeats_on")+","+
                                jsonObject.getString("bulk_input")+","+
                                jsonObject.getString("input_http_method")+","+
                                "'" +jsonObject.getString("api_endpoint")+"'"+","+
                                jsonObject.getString("api_timeout_in_ms")+","+
                                jsonObject.getString("response_type")+","+
                                jsonObject.getString("is_json_input_needed")+","+
                                jsonObject.getString("task_type")+","+
                                jsonObject.getString("is_active")+","+
                                jsonObject.getString("is_optional")+","+
                                "'" +jsonObject.getString("eta")+"'"+","+
                                (jsonObject.getString("service_id")==""? '0' : jsonObject.getString("service_id")) +","+
                                "'" +jsonObject.getString("email_list")+"'"+","+
                                "'" +jsonObject.getString("action")+ "'" + ");"; 
                
            client.query(query,resp->{
                if(resp.succeeded()){
                    context.response().setStatusCode(200).setStatusMessage("OK").end("Data added successfully");
                }else{
                    context.response().setStatusCode(500).end("Database error(Could not add data to the database)");
                }
            });         
        });
    }

    

    public static void main(String[] args) {
        Vertx vertx = Vertx.vertx();
        vertx.deployVerticle(new App());
    }
}